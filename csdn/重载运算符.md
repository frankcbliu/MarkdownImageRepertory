> 重载含**运算符重载**和**函数重载**
> 此处主要是**运算符重载**的实现demo

## 1. 重载 + 号 
```cpp
#include<iostream>
using namespace std;
class Num{
    int value;
public:
    Num(int _value){value=_value;}
    // 重载 + 号运算符
    Num operator + (const Num & n){
        return Num(value + n.value);
    }
};
int main()
{
    int a,b,c;
    a = 1; b = 2;
    c = a + b; // c = 3

    Num A(a),B(c);
    // 此处调用重载的运算符对类进行加法
    Num C = A + B; // C.value = 3

    return 0;
}

```

## 2. 重载 = 号
> reference: https://www.cnblogs.com/zpcdbky/p/5027481.html

### 2.1 关于重载赋值运算符的参数：

一般地，赋值运算符重载函数的参数是函数所在类的const类型的引用，**加const是因为：**

1. 我们不希望在这个函数中对用来进行赋值的"原版"做任何修改。
2. 加上const，对于const的和非const的实参，函数就能接受；如果不加，就只能接受非const的实参。

**用引用是因为：**

这样可以避免在函数调用时对实参的一次拷贝，提高了效率。

### 2.2 关于重载赋值运算符的返回值
一般地，返回值是被赋值者的引用，即*this，原因是

1. 这样在函数返回时避免一次拷贝，提高了效率。

2. 更重要的，这样可以实现连续赋值，即类似a=b=c这样。如果不是返回引用而是返回值类型，那么，执行a=b时，调用赋值运算符重载函数，在函数返回时，由于返回的是值类型，所以要对return后边的“东西”进行一次拷贝，得到一个未命名的副本（有些资料上称之为“匿名对象”），然后将这个副本返回，而这个副本是右值，所以，执行a=b后，得到的是一个右值，再执行=c就会出错。

> **注意：**
> 这也不是强制的，我们可以将函数返回值声明为void，然后什么也不返回，只不过这样就不能够连续赋值了。

### 2.3 关于重载赋值运算符的调用时机
如： 
```cpp
str2 = str1;//用str1为str2赋值，会由str2调用MyStr类的赋值运算符重载函数。
```
> 注意：**区分何时调用了拷贝构造函数，何时调用了重载的赋值运算符**

```cpp
Mystr str2;
str2 = str1;
```
与 `Mystr str2 = str1;` 有所区别，前者`Mystr str2;`是str2的声明与定义，`str2 = str1;`一句调用了 重载赋值运算符；后者`Mystr str2 = str1;`则调用了拷贝构造函数。

### 2.4 关于默认重载赋值运算符的时机
>  当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动生成这样一个赋值运算符重载函数。

可见，当用一个非类A的值（如上面的int型值）为类A的对象赋值时

1. 如果匹配的构造函数和赋值运算符重载函数同时存在（如例2），会调用赋值运算符重载函数。

2. 如果只有匹配的构造函数存在，就会调用这个构造函数。

### 2.5 显示提供重载赋值运算符的时机
1. 用非类A类型的值为类A的对象赋值时（当然，这种情况下我们可以不提供相应的赋值运算符重载函数而只提供相应的构造函数来完成任务）。

2. 当用类A类型的值为类A的对象赋值且类A的成员变量中含有指针时，为避免浅拷贝（关于浅拷贝和深拷贝，下面会讲到），必须显式提供赋值运算符重载函数。


### 2.6 例子
```cpp
#include<bits/stdc++.h>
using namespace std;

class Str{
private:
    int length;
    char *p;
public:
    Str(char *s) {
        length = (int)strlen(s);
        p = new char[length+1];
        strcpy(p, s);
    }
    Str(const Str &obj) {
        length = (int)strlen(obj.p);
        p = new char[length+1];
        strcpy(p, obj.p);
    }
    ~Str() { delete[] p; }

    // 重载赋值运算符
    void operator = (const Str &obj){
        this->p = new char[strlen(obj.p)];
        int i;
        for (i = 0; i <strlen(obj.p) ; ++i) {
            this->p[i] = obj.p[i];
        }
        this->p[i] = '\0';
        this->length = obj.length;
    };
    void show(){
        cout<<"length="<<length<<' '<<p<<endl;
    }
};

int main() {
    char *s1 = new char[100];
    cin.getline(s1,100);
    Str str1(s1);
    Str str2 = str1;
    str2.show();
    return 0;
}
```


### 2.7 深拷贝与浅拷贝（见另一篇文章）

### 2.8 赋值运算符重载函数只能是类的非静态的成员函数
> 其实，之所以不是静态成员函数，是因为静态成员函数只能操作类的静态成员，不能操作非静态成员。如果我们将赋值运算符重载函数定义为静态成员函数，那么，**该函数将无法操作类的非静态成员，这显然是不可行的。**

> 在前面的讲述中我们说过，**当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动提供一个**。现在，假设C++允许将赋值运算符重载函数定义为友元函数并且我们也确实这么做了，而且以类的引用为参数。与此同时，我们在类内却没有显式提供一个以本类或本类的引用为参数的赋值运算符重载函数。由于友元函数并不属于这个类，所以，此时编译器一看，**类内并没有一个以本类或本类的引用为参数的赋值运算符重载函数，所以会自动提供一个**。此时，我们再执行类似于str2=str1这样的代码，那么，编译器是该执行它提供的默认版本呢，还是执行我们定义的友元函数版本呢？

> 为了避免这样的二义性，C++强制规定，赋值运算符重载函数只能定义为类的成员函数，这样，编译器就能够判定是否要提供默认版本了，也不会再出现二义性。

### 2.9 赋值运算符重载函数不能被继承
why? 
> 原因：基类的赋值只能赋值基类成员，如果赋值重载可以继承，那么子类在没有重写赋值函数时，使用子类的赋值会调用基类的赋值，而基类的赋值无法给子类成员赋值。

注意，在基类写了重载赋值，子类没写的情况下，将子类强转为父类也可以通过编译。
例如：
```cpp
class A{
public:
    int X;
    A() {}
    A& operator =(const int x){
        X = x;
        return *this;
    }    
};
class B :public A{
public:
    B(void) :A() {}
};

int main(){
    (A)B = 67;// 将B类对象b强制转换成了A类对象
}
```

### 2.10 赋值运算符重载函数要避免自赋值
1. 提高效率

2. 如果类的数据成员中含有指针，自赋值有时会导致灾难性的后果。
> 对于指针间的赋值（注意这里指的是指针所指内容间的赋值，这里假设用_p给p赋值）

_p ----> p

- 先要将p所指向的空间delete掉（为什么要这么做呢？因为指针p所指的空间通常是new来的，如果在为p重新分配空间前没有将p原来的空间delete掉，会造成内存泄露）
> （所谓内存泄漏，就是p之前new出来的空间不再使用，但因为没有delete，后面也无法再使用，等同于内存白白浪费了）
- 然后再为p重新分配空间，将_p所指的内容拷贝到p所指的空间。如果是自赋值，那么p和_p是同一指针，在赋值操作前对p的delete操作，将导致p所指的数据同时被销毁。那么重新赋值时，拿什么来赋？

> 所以，对于赋值运算符重载函数，一定要先检查是否是自赋值，如果是，直接return *this。

**判断自赋值举例：**
```cpp
/*
class MyStr{
    char *name;
    int id;
}
*/

MyStr& operator =(const MyStr& str)//赋值运算符
{
    cout << "operator =" << endl;
    if (this != &str)//判断是否自赋值
    {
        if (name != NULL)
            delete[] name;
        this->id = str.id;
        int len = strlen(str.name);
        name = new char[len + 1];
        strcpy_s(name, strlen(str.name) + 1, str.name);
    }
    return *this;
}
```

